"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getParentFunctionOrStatement = getParentFunctionOrStatement;
exports.markNodeAsTracked = markNodeAsTracked;
exports.isNodeTracked = isNodeTracked;
exports.isNodeExternal = isNodeExternal;
exports.isNodeUsed = isNodeUsed;
exports.markNodeAsUsed = markNodeAsUsed;
exports.markNodeAsExternal = markNodeAsExternal;
exports.isNodeBindingUsed = isNodeBindingUsed;
exports.isNodeBindingExternal = isNodeBindingExternal;
exports.getSideInDeclaration = getSideInDeclaration;
exports.getSideInObjectProperty = getSideInObjectProperty;
exports.isObjectPropertyDeclaration = isObjectPropertyDeclaration;
exports.getSideInAssignmentExpression = getSideInAssignmentExpression;
exports.getSideInImportSpecifier = getSideInImportSpecifier;
exports.getSideInFunction = getSideInFunction;
exports.EXCLUDED_NODES = exports.SYM_IDENTIFIER_EXTERNAL = exports.SYM_IDENTIFIER_TRACKED = exports.SYM_IDENTIFIER_USED = void 0;

var babelTypes = _interopRequireWildcard(require("@babel/types"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

const SYM_IDENTIFIER_USED = Symbol('IDENTIFIER_USED');
exports.SYM_IDENTIFIER_USED = SYM_IDENTIFIER_USED;
const SYM_IDENTIFIER_TRACKED = Symbol('IDENTIFIER_TRACKED');
exports.SYM_IDENTIFIER_TRACKED = SYM_IDENTIFIER_TRACKED;
const SYM_IDENTIFIER_EXTERNAL = Symbol('IDENTIFIER_EXTERNAL');
exports.SYM_IDENTIFIER_EXTERNAL = SYM_IDENTIFIER_EXTERNAL;
const EXCLUDED_NODES = new Set(['this']);
exports.EXCLUDED_NODES = EXCLUDED_NODES;

function getParentFunctionOrStatement(path) {
  do {
    if (!path.parentPath || Array.isArray(path.container) && path.isStatement() || path.isFunction()) {
      break;
    } else {
      path = path.parentPath;
    }
  } while (path);

  if (path && (path.isProgram() || path.isFile())) {
    return null;
  }

  return path;
}

function markNodeAsTracked(node) {
  node[SYM_IDENTIFIER_TRACKED] = true;
  node[SYM_IDENTIFIER_USED] = false;
  node[SYM_IDENTIFIER_EXTERNAL] = false;
}

function isNodeTracked(node) {
  return !!node[SYM_IDENTIFIER_TRACKED];
}

function isNodeExternal(node) {
  return !!node[SYM_IDENTIFIER_EXTERNAL];
}

function isNodeUsed(node) {
  return EXCLUDED_NODES.has(node.name) || !!node[SYM_IDENTIFIER_USED];
}

function markNodeAsUsed(path) {
  const binding = path.scope.getBindingIdentifier(path.node.name);

  if (binding) {
    if (!isNodeTracked(binding)) {
      return;
    }

    binding[SYM_IDENTIFIER_USED] = true;
  }
}

function markNodeAsExternal(path) {
  const binding = path.scope.getBindingIdentifier(path.node.name);

  if (binding) {
    if (!isNodeTracked(binding)) {
      return;
    }

    binding[SYM_IDENTIFIER_EXTERNAL] = true;
  }
}

function isNodeBindingUsed(path) {
  const binding = path.scope.getBindingIdentifier(path.node.name);

  if (binding) {
    if (!isNodeTracked(binding)) {
      // console.log('node is not tracked', binding)
      return true;
    }

    return binding[SYM_IDENTIFIER_USED];
  }

  return true;
}

function isNodeBindingExternal(path) {
  const binding = path.scope.getBindingIdentifier(path.node.name);

  if (binding) {
    if (isNodeExternal(binding)) {
      return true;
    }

    return binding[SYM_IDENTIFIER_EXTERNAL];
  }

  return true;
}

function getSideInDeclaration(child, parent) {
  let currentItem = child;
  const {
    declarations
  } = parent.node;
  const length = declarations.length;

  do {
    for (let i = 0; i < length; i++) {
      // It's a usage whenever it's a type reference
      if (babelTypes.isTSTypeReference(currentItem)) {
        return 'right';
      }

      if (declarations[i].id === currentItem.node) {
        return 'left';
      }

      if (declarations[i].init === currentItem.node) {
        return 'right';
      }
    }

    currentItem = currentItem.parentPath;
  } while (currentItem);

  return null;
}

function getSideInObjectProperty(child, parent) {
  if (!parent.node) {
    return null;
  }

  let currentItem = child;

  do {
    if (currentItem.node === parent.node.key) {
      return 'left';
    }

    if (currentItem.node === parent.node.value) {
      return 'right';
    }

    currentItem = currentItem.parentPath;
  } while (currentItem);

  return null;
}

function isObjectPropertyDeclaration(child, parent) {
  const side = getSideInObjectProperty(child, parent);
  return side === 'right' || side === 'left' && babelTypes.isAssignmentPattern(parent.node.value);
}

function getSideInAssignmentExpression(child, parent) {
  if (!parent.node) {
    return null;
  }

  let currentItem = child;

  do {
    // If it's an object, anything other than object being written to is a usage
    if (babelTypes.isMemberExpression(currentItem) && currentItem.node.object !== child.node) {
      return 'right';
    }

    if (currentItem.node === parent.node.left) {
      return 'left';
    }

    if (currentItem.node === parent.node.right) {
      return 'right';
    }

    currentItem = currentItem.parentPath;
  } while (currentItem);

  return null;
}

function getSideInImportSpecifier(child) {
  let currentItem = child;

  do {
    const parentPath = currentItem.parentPath;

    if (parentPath.node) {
      if (currentItem.node === parentPath.node.imported) {
        return 'left';
      }

      if (currentItem.node === parentPath.node.local) {
        return 'right';
      }
    } else break;
  } while (currentItem);

  return null;
}

function getSideInFunction(child, parent) {
  if (!parent.node) {
    return null;
  }

  let currentItem = child;

  do {
    if (currentItem.node === parent.node.id) {
      return null;
    } // It's a usage whenever it's a type reference


    if (babelTypes.isTSTypeReference(currentItem)) {
      return 'body';
    }

    if (parent.node.params.some(item => item === currentItem.node)) {
      return 'params';
    }

    if (currentItem.node === parent.node) {
      return 'body';
    }

    currentItem = currentItem.parentPath;
  } while (currentItem);

  return null;
}